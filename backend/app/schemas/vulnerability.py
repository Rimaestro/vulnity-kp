"""
Vulnerability schemas for request/response validation
Pydantic models for vulnerability data validation
Based on existing auth.py patterns and DVWA analysis findings
"""

from datetime import datetime
from typing import Optional, List, Dict, Any
from pydantic import BaseModel, Field, field_validator, ConfigDict

from app.models.vulnerability import VulnerabilityType, VulnerabilityRisk, VulnerabilityStatus


class VulnerabilityResponse(BaseModel):
    """Vulnerability response schema following auth.py patterns"""
    model_config = ConfigDict(from_attributes=True)
    
    id: int = Field(..., description="Vulnerability ID")
    title: str = Field(..., description="Vulnerability title")
    description: Optional[str] = Field(None, description="Detailed description")
    vulnerability_type: str = Field(..., description="Type of vulnerability")
    risk: str = Field(..., description="Risk level")
    status: str = Field(..., description="Vulnerability status")
    
    # Location information
    endpoint: str = Field(..., description="Vulnerable endpoint")
    parameter: Optional[str] = Field(None, description="Vulnerable parameter")
    method: str = Field(..., description="HTTP method")
    
    # Detection information
    payload: Optional[str] = Field(None, description="Payload that triggered vulnerability")
    confidence: float = Field(..., description="Detection confidence score")
    
    # Technical details
    cwe_id: Optional[str] = Field(None, description="CWE identifier")
    cvss_score: Optional[float] = Field(None, description="CVSS score")
    owasp_category: Optional[str] = Field(None, description="OWASP category")
    
    # Timestamps
    created_at: datetime = Field(..., description="Discovery time")
    verified: bool = Field(..., description="Verification status")
    verified_at: Optional[datetime] = Field(None, description="Verification time")
    
    # Scan relationship
    scan_id: int = Field(..., description="Associated scan ID")


class VulnerabilityDetailResponse(BaseModel):
    """Detailed vulnerability response schema"""
    model_config = ConfigDict(from_attributes=True)
    
    id: int = Field(..., description="Vulnerability ID")
    title: str = Field(..., description="Vulnerability title")
    description: Optional[str] = Field(None, description="Detailed description")
    vulnerability_type: str = Field(..., description="Type of vulnerability")
    risk: str = Field(..., description="Risk level")
    status: str = Field(..., description="Vulnerability status")
    
    # Location information
    endpoint: str = Field(..., description="Vulnerable endpoint")
    parameter: Optional[str] = Field(None, description="Vulnerable parameter")
    method: str = Field(..., description="HTTP method")
    
    # Detection information
    payload: Optional[str] = Field(None, description="Payload that triggered vulnerability")
    confidence: float = Field(..., description="Detection confidence score")
    
    # Evidence and proof
    evidence: Optional[Dict[str, Any]] = Field(None, description="Structured evidence data")
    request_data: Optional[Dict[str, Any]] = Field(None, description="HTTP request data")
    response_data: Optional[Dict[str, Any]] = Field(None, description="HTTP response data")
    
    # Technical details
    cwe_id: Optional[str] = Field(None, description="CWE identifier")
    cvss_score: Optional[float] = Field(None, description="CVSS score")
    owasp_category: Optional[str] = Field(None, description="OWASP category")
    
    # Remediation information
    remediation: Optional[str] = Field(None, description="Remediation guidance")
    references: Optional[List[str]] = Field(None, description="Reference URLs")
    
    # Verification information
    verified: bool = Field(..., description="Verification status")
    verified_at: Optional[datetime] = Field(None, description="Verification time")
    verification_notes: Optional[str] = Field(None, description="Verification notes")
    
    # Timestamps
    created_at: datetime = Field(..., description="Discovery time")
    updated_at: datetime = Field(..., description="Last update time")
    
    # Scan relationship
    scan_id: int = Field(..., description="Associated scan ID")


class VulnerabilityListResponse(BaseModel):
    """Vulnerability list item response schema"""
    model_config = ConfigDict(from_attributes=True)
    
    id: int = Field(..., description="Vulnerability ID")
    title: str = Field(..., description="Vulnerability title")
    vulnerability_type: str = Field(..., description="Type of vulnerability")
    risk: str = Field(..., description="Risk level")
    status: str = Field(..., description="Vulnerability status")
    endpoint: str = Field(..., description="Vulnerable endpoint")
    parameter: Optional[str] = Field(None, description="Vulnerable parameter")
    confidence: float = Field(..., description="Detection confidence score")
    verified: bool = Field(..., description="Verification status")
    created_at: datetime = Field(..., description="Discovery time")
    scan_id: int = Field(..., description="Associated scan ID")


class VulnerabilityUpdateRequest(BaseModel):
    """Schema for updating vulnerability status"""
    status: str = Field(..., description="New vulnerability status")
    verification_notes: Optional[str] = Field(None, max_length=1000, description="Verification notes")
    
    @field_validator('status')
    @classmethod
    def validate_status(cls, v: str) -> str:
        """Validate vulnerability status"""
        valid_statuses = [status.value for status in VulnerabilityStatus]
        if v not in valid_statuses:
            raise ValueError(f'Invalid status: {v}. Valid statuses: {valid_statuses}')
        return v


class VulnerabilityStatsResponse(BaseModel):
    """Vulnerability statistics response schema"""
    total_vulnerabilities: int = Field(..., description="Total vulnerabilities")
    critical_count: int = Field(..., description="Critical vulnerabilities")
    high_count: int = Field(..., description="High risk vulnerabilities")
    medium_count: int = Field(..., description="Medium risk vulnerabilities")
    low_count: int = Field(..., description="Low risk vulnerabilities")
    info_count: int = Field(..., description="Informational vulnerabilities")
    
    # By type
    sql_injection_count: int = Field(..., description="SQL injection vulnerabilities")
    xss_count: int = Field(..., description="XSS vulnerabilities")
    csrf_count: int = Field(..., description="CSRF vulnerabilities")
    
    # By status
    open_count: int = Field(..., description="Open vulnerabilities")
    confirmed_count: int = Field(..., description="Confirmed vulnerabilities")
    false_positive_count: int = Field(..., description="False positive vulnerabilities")
    fixed_count: int = Field(..., description="Fixed vulnerabilities")
    
    # Verification
    verified_count: int = Field(..., description="Verified vulnerabilities")
    unverified_count: int = Field(..., description="Unverified vulnerabilities")


class VulnerabilityFilterRequest(BaseModel):
    """Schema for filtering vulnerabilities"""
    risk_levels: Optional[List[str]] = Field(None, description="Filter by risk levels")
    vulnerability_types: Optional[List[str]] = Field(None, description="Filter by vulnerability types")
    statuses: Optional[List[str]] = Field(None, description="Filter by statuses")
    verified_only: Optional[bool] = Field(None, description="Show only verified vulnerabilities")
    scan_id: Optional[int] = Field(None, description="Filter by scan ID")
    endpoint_contains: Optional[str] = Field(None, description="Filter by endpoint containing text")
    
    @field_validator('risk_levels')
    @classmethod
    def validate_risk_levels(cls, v: Optional[List[str]]) -> Optional[List[str]]:
        """Validate risk levels"""
        if v is None:
            return v
        
        valid_risks = [risk.value for risk in VulnerabilityRisk]
        for risk in v:
            if risk not in valid_risks:
                raise ValueError(f'Invalid risk level: {risk}. Valid levels: {valid_risks}')
        return v
    
    @field_validator('vulnerability_types')
    @classmethod
    def validate_vulnerability_types(cls, v: Optional[List[str]]) -> Optional[List[str]]:
        """Validate vulnerability types"""
        if v is None:
            return v
        
        valid_types = [vuln_type.value for vuln_type in VulnerabilityType]
        for vuln_type in v:
            if vuln_type not in valid_types:
                raise ValueError(f'Invalid vulnerability type: {vuln_type}. Valid types: {valid_types}')
        return v
    
    @field_validator('statuses')
    @classmethod
    def validate_statuses(cls, v: Optional[List[str]]) -> Optional[List[str]]:
        """Validate statuses"""
        if v is None:
            return v
        
        valid_statuses = [status.value for status in VulnerabilityStatus]
        for status in v:
            if status not in valid_statuses:
                raise ValueError(f'Invalid status: {status}. Valid statuses: {valid_statuses}')
        return v


class VulnerabilityExportRequest(BaseModel):
    """Schema for exporting vulnerabilities"""
    format: str = Field(..., description="Export format (json, csv, pdf)")
    include_evidence: bool = Field(default=True, description="Include evidence data")
    include_remediation: bool = Field(default=True, description="Include remediation guidance")
    filter_params: Optional[VulnerabilityFilterRequest] = Field(None, description="Filter parameters")
    
    @field_validator('format')
    @classmethod
    def validate_format(cls, v: str) -> str:
        """Validate export format"""
        valid_formats = ['json', 'csv', 'pdf']
        if v.lower() not in valid_formats:
            raise ValueError(f'Invalid format: {v}. Valid formats: {valid_formats}')
        return v.lower()
