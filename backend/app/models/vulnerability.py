"""
Vulnerability models for storing scan results
Based on DVWA analysis findings and SQL injection detection patterns
"""

import enum
from typing import Optional, Dict, Any
from sqlalchemy import Column, String, Text, Integer, ForeignKey, Enum, Float, JSON, Boolean, DateTime
from sqlalchemy.orm import relationship

from .database import BaseModel


class VulnerabilityType(enum.Enum):
    """Vulnerability type enumeration based on DVWA analysis"""
    SQL_INJECTION = "sql_injection"
    ERROR_BASED_SQLI = "error_based_sql_injection"
    UNION_BASED_SQLI = "union_based_sql_injection"
    BOOLEAN_BLIND_SQLI = "boolean_blind_sql_injection"
    TIME_BASED_SQLI = "time_based_sql_injection"
    XSS_REFLECTED = "xss_reflected"
    XSS_STORED = "xss_stored"
    XSS_DOM = "xss_dom"
    CSRF = "csrf"
    DIRECTORY_TRAVERSAL = "directory_traversal"
    FILE_INCLUSION = "file_inclusion"
    COMMAND_INJECTION = "command_injection"
    AUTHENTICATION_BYPASS = "authentication_bypass"
    SESSION_FIXATION = "session_fixation"
    INSECURE_DIRECT_OBJECT_REFERENCE = "insecure_direct_object_reference"


class VulnerabilityRisk(enum.Enum):
    """Vulnerability risk level enumeration"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class VulnerabilityStatus(enum.Enum):
    """Vulnerability status enumeration"""
    OPEN = "open"
    CONFIRMED = "confirmed"
    FALSE_POSITIVE = "false_positive"
    FIXED = "fixed"
    ACCEPTED_RISK = "accepted_risk"


class Vulnerability(BaseModel):
    """
    Vulnerability model for storing detailed vulnerability information
    Based on DVWA SQL injection analysis findings
    """
    
    __tablename__ = "vulnerabilities"
    
    # Basic vulnerability information
    title = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    vulnerability_type = Column(Enum(VulnerabilityType), nullable=False, index=True)
    risk = Column(Enum(VulnerabilityRisk), nullable=False, index=True)
    status = Column(Enum(VulnerabilityStatus), default=VulnerabilityStatus.OPEN, nullable=False)
    
    # Location information
    endpoint = Column(String(2048), nullable=False)
    parameter = Column(String(255), nullable=True)
    method = Column(String(10), nullable=False, default="GET")  # HTTP method
    
    # Detection information
    payload = Column(Text, nullable=True)  # The payload that triggered the vulnerability
    confidence = Column(Float, nullable=False)  # Confidence score (0.0 - 1.0)
    
    # Evidence and proof
    evidence = Column(JSON, nullable=True)  # Structured evidence data
    request_data = Column(JSON, nullable=True)  # HTTP request that found the vulnerability
    response_data = Column(JSON, nullable=True)  # HTTP response that confirmed the vulnerability
    
    # Technical details
    cwe_id = Column(String(20), nullable=True)  # CWE identifier
    cvss_score = Column(Float, nullable=True)  # CVSS score if applicable
    owasp_category = Column(String(100), nullable=True)  # OWASP Top 10 category
    
    # Remediation information
    remediation = Column(Text, nullable=True)
    references = Column(JSON, nullable=True)  # List of reference URLs
    
    # Verification information
    verified = Column(Boolean, default=False, nullable=False)
    verified_at = Column(DateTime, nullable=True)
    verification_notes = Column(Text, nullable=True)
    
    # Scan relationship (following existing pattern)
    scan_id = Column(Integer, ForeignKey("scans.id"), nullable=False, index=True)
    scan = relationship("Scan", back_populates="vulnerabilities")
    
    def __repr__(self):
        return f"<Vulnerability(id={self.id}, type='{self.vulnerability_type.value}', risk='{self.risk.value}')>"
    
    def is_critical(self) -> bool:
        """Check if vulnerability is critical"""
        return self.risk == VulnerabilityRisk.CRITICAL
    
    def is_high_risk(self) -> bool:
        """Check if vulnerability is high risk"""
        return self.risk in [VulnerabilityRisk.CRITICAL, VulnerabilityRisk.HIGH]
    
    def is_sql_injection(self) -> bool:
        """Check if vulnerability is SQL injection related"""
        sql_injection_types = [
            VulnerabilityType.SQL_INJECTION,
            VulnerabilityType.ERROR_BASED_SQLI,
            VulnerabilityType.UNION_BASED_SQLI,
            VulnerabilityType.BOOLEAN_BLIND_SQLI,
            VulnerabilityType.TIME_BASED_SQLI
        ]
        return self.vulnerability_type in sql_injection_types
    
    def get_risk_score(self) -> int:
        """Get numeric risk score for sorting"""
        risk_scores = {
            VulnerabilityRisk.CRITICAL: 5,
            VulnerabilityRisk.HIGH: 4,
            VulnerabilityRisk.MEDIUM: 3,
            VulnerabilityRisk.LOW: 2,
            VulnerabilityRisk.INFO: 1
        }
        return risk_scores.get(self.risk, 0)
    
    def get_cwe_url(self) -> Optional[str]:
        """Get CWE reference URL"""
        if self.cwe_id:
            return f"https://cwe.mitre.org/data/definitions/{self.cwe_id.replace('CWE-', '')}.html"
        return None
    
    def set_sql_injection_details(self, sqli_type: str, payload: str, evidence: Dict[str, Any]):
        """
        Set SQL injection specific details based on DVWA analysis findings
        """
        # Map DVWA findings to vulnerability types
        type_mapping = {
            'error_based': VulnerabilityType.ERROR_BASED_SQLI,
            'union_based': VulnerabilityType.UNION_BASED_SQLI,
            'boolean_blind': VulnerabilityType.BOOLEAN_BLIND_SQLI,
            'time_based': VulnerabilityType.TIME_BASED_SQLI
        }
        
        self.vulnerability_type = type_mapping.get(sqli_type, VulnerabilityType.SQL_INJECTION)
        self.payload = payload
        self.evidence = evidence
        self.cwe_id = "CWE-89"  # SQL Injection CWE
        self.owasp_category = "A03:2021 â€“ Injection"
        
        # Set risk based on type and evidence
        if sqli_type in ['error_based', 'union_based']:
            self.risk = VulnerabilityRisk.CRITICAL
        elif sqli_type in ['boolean_blind', 'time_based']:
            self.risk = VulnerabilityRisk.HIGH
        else:
            self.risk = VulnerabilityRisk.HIGH
        
        # Set remediation guidance
        self.remediation = """
        1. Use parameterized queries (prepared statements) instead of string concatenation
        2. Implement proper input validation and sanitization
        3. Use stored procedures with parameterized inputs
        4. Apply the principle of least privilege for database accounts
        5. Enable SQL query logging and monitoring
        6. Regularly update database software and apply security patches
        """
        
        # Set references
        self.references = [
            "https://owasp.org/www-community/attacks/SQL_Injection",
            "https://cwe.mitre.org/data/definitions/89.html",
            "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
        ]
    
    def to_dict(self):
        """Convert vulnerability to dictionary with additional computed fields"""
        data = super().to_dict()
        data.update({
            'is_critical': self.is_critical(),
            'is_high_risk': self.is_high_risk(),
            'is_sql_injection': self.is_sql_injection(),
            'risk_score': self.get_risk_score(),
            'cwe_url': self.get_cwe_url()
        })
        return data
