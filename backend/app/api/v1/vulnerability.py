"""
Vulnerability API endpoints for managing scan results
Following existing auth.py patterns and DVWA analysis findings
"""

from datetime import datetime
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, status, Request, Query
from sqlalchemy.orm import Session
from sqlalchemy import desc, asc, and_, or_

from app.config.database import get_db
from app.config.logging import get_logger
from app.api.dependencies import get_current_user, api_rate_limit, get_client_ip
from app.models.user import User
from app.models.scan import Scan
from app.models.vulnerability import Vulnerability, VulnerabilityRisk, VulnerabilityStatus, VulnerabilityType
from app.schemas.vulnerability import (
    VulnerabilityResponse, VulnerabilityDetailResponse, VulnerabilityListResponse,
    VulnerabilityUpdateRequest, VulnerabilityStatsResponse, VulnerabilityFilterRequest
)

# Setup logging following existing pattern
vulnerability_logger = get_logger("vulnerability")
security_logger = get_logger("security")

# Create router following auth.py pattern
router = APIRouter(prefix="/vulnerability", tags=["vulnerabilities"])


@router.get("/", response_model=List[VulnerabilityListResponse])
async def list_vulnerabilities(
    request: Request,
    skip: int = Query(0, ge=0, description="Number of vulnerabilities to skip"),
    limit: int = Query(50, ge=1, le=100, description="Number of vulnerabilities to return"),
    scan_id: Optional[int] = Query(None, description="Filter by scan ID"),
    risk_level: Optional[str] = Query(None, description="Filter by risk level"),
    vulnerability_type: Optional[str] = Query(None, description="Filter by vulnerability type"),
    status_filter: Optional[str] = Query(None, description="Filter by status"),
    verified_only: Optional[bool] = Query(None, description="Show only verified vulnerabilities"),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    List user's vulnerabilities with filtering and pagination
    Following existing auth.py patterns
    """
    
    client_ip = get_client_ip(request)
    vulnerability_logger.info(f"Vulnerability list request from user: {current_user.username} from {client_ip}")
    
    # Build base query - only vulnerabilities from user's scans
    query = db.query(Vulnerability).join(Scan).filter(
        Scan.user_id == current_user.id,
        Scan.is_deleted == False
    )
    
    # Apply filters
    if scan_id:
        query = query.filter(Vulnerability.scan_id == scan_id)
    
    if risk_level:
        try:
            risk_enum = VulnerabilityRisk(risk_level)
            query = query.filter(Vulnerability.risk == risk_enum)
        except ValueError:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid risk level: {risk_level}"
            )
    
    if vulnerability_type:
        try:
            type_enum = VulnerabilityType(vulnerability_type)
            query = query.filter(Vulnerability.vulnerability_type == type_enum)
        except ValueError:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid vulnerability type: {vulnerability_type}"
            )
    
    if status_filter:
        try:
            status_enum = VulnerabilityStatus(status_filter)
            query = query.filter(Vulnerability.status == status_enum)
        except ValueError:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid status: {status_filter}"
            )
    
    if verified_only is not None:
        query = query.filter(Vulnerability.verified == verified_only)
    
    # Apply pagination and ordering (highest risk first)
    vulnerabilities = query.order_by(
        desc(Vulnerability.risk),
        desc(Vulnerability.confidence),
        desc(Vulnerability.created_at)
    ).offset(skip).limit(limit).all()
    
    return [VulnerabilityListResponse.model_validate(vuln) for vuln in vulnerabilities]


@router.get("/{vulnerability_id}", response_model=VulnerabilityDetailResponse)
async def get_vulnerability_detail(
    vulnerability_id: int,
    request: Request,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Get detailed vulnerability information
    Following existing auth.py security patterns
    """
    
    client_ip = get_client_ip(request)
    
    # Get vulnerability with ownership check through scan
    vulnerability = db.query(Vulnerability).join(Scan).filter(
        Vulnerability.id == vulnerability_id,
        Scan.user_id == current_user.id,
        Scan.is_deleted == False
    ).first()
    
    if not vulnerability:
        vulnerability_logger.warning(f"Unauthorized vulnerability access attempt by {current_user.username} for vulnerability {vulnerability_id} from {client_ip}")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Vulnerability not found"
        )
    
    vulnerability_logger.info(f"Vulnerability detail request for {vulnerability_id} by user: {current_user.username}")
    
    return VulnerabilityDetailResponse.model_validate(vulnerability)


@router.patch("/{vulnerability_id}", response_model=VulnerabilityResponse)
async def update_vulnerability(
    vulnerability_id: int,
    update_request: VulnerabilityUpdateRequest,
    request: Request,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Update vulnerability status and verification
    Following existing auth.py patterns
    """
    
    client_ip = get_client_ip(request)
    
    # Get vulnerability with ownership check
    vulnerability = db.query(Vulnerability).join(Scan).filter(
        Vulnerability.id == vulnerability_id,
        Scan.user_id == current_user.id,
        Scan.is_deleted == False
    ).first()
    
    if not vulnerability:
        vulnerability_logger.warning(f"Unauthorized vulnerability update attempt by {current_user.username} for vulnerability {vulnerability_id}")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Vulnerability not found"
        )
    
    # Update vulnerability
    old_status = vulnerability.status.value
    vulnerability.status = VulnerabilityStatus(update_request.status)
    
    if update_request.verification_notes:
        vulnerability.verification_notes = update_request.verification_notes
        vulnerability.verified = True
        vulnerability.verified_at = datetime.utcnow()
    
    db.commit()
    db.refresh(vulnerability)
    
    vulnerability_logger.info(f"Vulnerability {vulnerability_id} status updated from {old_status} to {vulnerability.status.value} by user: {current_user.username}")
    
    return VulnerabilityResponse.model_validate(vulnerability)


@router.get("/stats/summary", response_model=VulnerabilityStatsResponse)
async def get_vulnerability_stats(
    scan_id: Optional[int] = Query(None, description="Filter stats by scan ID"),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Get vulnerability statistics for current user
    Following existing auth.py patterns
    """
    
    # Build base query for user's vulnerabilities
    query = db.query(Vulnerability).join(Scan).filter(
        Scan.user_id == current_user.id,
        Scan.is_deleted == False
    )
    
    # Apply scan filter if provided
    if scan_id:
        query = query.filter(Vulnerability.scan_id == scan_id)
    
    vulnerabilities = query.all()
    
    # Calculate statistics
    total_vulnerabilities = len(vulnerabilities)
    
    # By risk level
    critical_count = sum(1 for v in vulnerabilities if v.risk == VulnerabilityRisk.CRITICAL)
    high_count = sum(1 for v in vulnerabilities if v.risk == VulnerabilityRisk.HIGH)
    medium_count = sum(1 for v in vulnerabilities if v.risk == VulnerabilityRisk.MEDIUM)
    low_count = sum(1 for v in vulnerabilities if v.risk == VulnerabilityRisk.LOW)
    info_count = sum(1 for v in vulnerabilities if v.risk == VulnerabilityRisk.INFO)
    
    # By type (SQL injection focus based on DVWA analysis)
    sql_injection_count = sum(1 for v in vulnerabilities if v.is_sql_injection())
    xss_count = sum(1 for v in vulnerabilities if 'xss' in v.vulnerability_type.value)
    csrf_count = sum(1 for v in vulnerabilities if v.vulnerability_type == VulnerabilityType.CSRF)
    
    # By status
    open_count = sum(1 for v in vulnerabilities if v.status == VulnerabilityStatus.OPEN)
    confirmed_count = sum(1 for v in vulnerabilities if v.status == VulnerabilityStatus.CONFIRMED)
    false_positive_count = sum(1 for v in vulnerabilities if v.status == VulnerabilityStatus.FALSE_POSITIVE)
    fixed_count = sum(1 for v in vulnerabilities if v.status == VulnerabilityStatus.FIXED)
    
    # By verification
    verified_count = sum(1 for v in vulnerabilities if v.verified)
    unverified_count = total_vulnerabilities - verified_count
    
    return VulnerabilityStatsResponse(
        total_vulnerabilities=total_vulnerabilities,
        critical_count=critical_count,
        high_count=high_count,
        medium_count=medium_count,
        low_count=low_count,
        info_count=info_count,
        sql_injection_count=sql_injection_count,
        xss_count=xss_count,
        csrf_count=csrf_count,
        open_count=open_count,
        confirmed_count=confirmed_count,
        false_positive_count=false_positive_count,
        fixed_count=fixed_count,
        verified_count=verified_count,
        unverified_count=unverified_count
    )


@router.post("/{vulnerability_id}/verify", response_model=VulnerabilityResponse)
async def verify_vulnerability(
    vulnerability_id: str,
    request: Request,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Mark vulnerability as verified
    Following existing auth.py security patterns
    """
    
    client_ip = get_client_ip(request)
    
    # Get vulnerability with ownership check
    vulnerability = db.query(Vulnerability).join(Scan).filter(
        Vulnerability.id == vulnerability_id,
        Scan.user_id == current_user.id,
        Scan.is_deleted == False
    ).first()
    
    if not vulnerability:
        vulnerability_logger.warning(f"Unauthorized vulnerability verification attempt by {current_user.username} for vulnerability {vulnerability_id}")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Vulnerability not found"
        )
    
    # Mark as verified
    vulnerability.verified = True
    vulnerability.verified_at = datetime.utcnow()
    
    # If not already confirmed, mark as confirmed
    if vulnerability.status == VulnerabilityStatus.OPEN:
        vulnerability.status = VulnerabilityStatus.CONFIRMED
    
    db.commit()
    db.refresh(vulnerability)
    
    vulnerability_logger.info(f"Vulnerability {vulnerability_id} verified by user: {current_user.username}")
    
    return VulnerabilityResponse.model_validate(vulnerability)


@router.get("/scan/{scan_id}", response_model=List[VulnerabilityListResponse])
async def get_scan_vulnerabilities(
    scan_id: str,
    request: Request,
    skip: int = Query(0, ge=0, description="Number of vulnerabilities to skip"),
    limit: int = Query(50, ge=1, le=100, description="Number of vulnerabilities to return"),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Get vulnerabilities for a specific scan
    Following existing auth.py security patterns
    """
    
    client_ip = get_client_ip(request)
    
    # Verify scan ownership
    scan = db.query(Scan).filter(
        Scan.id == scan_id,
        Scan.user_id == current_user.id,
        Scan.is_deleted == False
    ).first()
    
    if not scan:
        vulnerability_logger.warning(f"Unauthorized scan vulnerability access attempt by {current_user.username} for scan {scan_id}")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Scan not found"
        )
    
    # Get vulnerabilities for the scan
    vulnerabilities = db.query(Vulnerability).filter(
        Vulnerability.scan_id == scan_id
    ).order_by(
        desc(Vulnerability.risk),
        desc(Vulnerability.confidence),
        desc(Vulnerability.created_at)
    ).offset(skip).limit(limit).all()
    
    vulnerability_logger.info(f"Scan vulnerabilities request for scan {scan_id} by user: {current_user.username}")
    
    return [VulnerabilityListResponse.model_validate(vuln) for vuln in vulnerabilities]
