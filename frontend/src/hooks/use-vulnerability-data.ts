import { useState, useEffect } from "react"

export interface VulnerabilityItem {
  id: string
  type: "sql-injection" | "xss" | "csrf" | "file-upload" | "auth-bypass" | "info-disclosure" | "dos" | "rce"
  title: string
  description: string
  severity: "critical" | "high" | "medium" | "low"
  status: "open" | "in-progress" | "fixed" | "dismissed"
  target: string
  discoveredAt: Date
  lastUpdated: Date
  cve?: string
  cvssScore?: number
  impact: "high" | "medium" | "low"
  exploitability: "high" | "medium" | "low"
  fixComplexity: "low" | "medium" | "high"
  estimatedFixTime: number // in hours
  assignedTo?: string
  tags: string[]
}

export interface VulnerabilityStats {
  critical: number
  high: number
  medium: number
  low: number
  total: number
  fixed: number
  inProgress: number
  open: number
}

export interface RiskMetrics {
  riskScore: number // 0-10
  slaCompliance: number // percentage
  averageFixTime: number // in days
  criticalSlaBreaches: number
  trendDirection: "up" | "down" | "stable"
  trendPercentage: number
}

export interface VulnerabilityTrend {
  date: string
  critical: number
  high: number
  medium: number
  low: number
  total: number
  fixed: number
}

// Mock data generator
function generateMockVulnerabilities(): VulnerabilityItem[] {
  const now = new Date()
  const vulnerabilities: VulnerabilityItem[] = [
    {
      id: "vuln-1",
      type: "sql-injection",
      title: "SQL Injection in Login Form",
      description: "User input is not properly sanitized in the login endpoint, allowing SQL injection attacks.",
      severity: "critical",
      status: "open",
      target: "/api/auth/login",
      discoveredAt: new Date(now.getTime() - 2 * 24 * 60 * 60 * 1000), // 2 days ago
      lastUpdated: new Date(now.getTime() - 1 * 24 * 60 * 60 * 1000), // 1 day ago
      cve: "CVE-2024-1234",
      cvssScore: 9.8,
      impact: "high",
      exploitability: "high",
      fixComplexity: "medium",
      estimatedFixTime: 8,
      assignedTo: "Security Team",
      tags: ["authentication", "database", "injection"]
    },
    {
      id: "vuln-2",
      type: "sql-injection",
      title: "SQL Injection in Search Function",
      description: "Search parameter allows SQL injection through unsanitized input.",
      severity: "critical",
      status: "in-progress",
      target: "/api/search",
      discoveredAt: new Date(now.getTime() - 5 * 24 * 60 * 60 * 1000),
      lastUpdated: new Date(now.getTime() - 2 * 60 * 60 * 1000), // 2 hours ago
      cve: "CVE-2024-1235",
      cvssScore: 8.9,
      impact: "high",
      exploitability: "medium",
      fixComplexity: "low",
      estimatedFixTime: 4,
      assignedTo: "Backend Team",
      tags: ["search", "database", "injection"]
    },
    {
      id: "vuln-3",
      type: "xss",
      title: "Stored XSS in Comment Section",
      description: "User comments are not properly escaped, allowing stored XSS attacks.",
      severity: "high",
      status: "open",
      target: "/comments",
      discoveredAt: new Date(now.getTime() - 1 * 24 * 60 * 60 * 1000),
      lastUpdated: new Date(now.getTime() - 1 * 24 * 60 * 60 * 1000),
      cvssScore: 7.5,
      impact: "medium",
      exploitability: "high",
      fixComplexity: "low",
      estimatedFixTime: 2,
      tags: ["xss", "comments", "frontend"]
    },
    {
      id: "vuln-4",
      type: "xss",
      title: "Reflected XSS in Search Results",
      description: "Search query is reflected in results without proper encoding.",
      severity: "high",
      status: "open",
      target: "/search",
      discoveredAt: new Date(now.getTime() - 3 * 24 * 60 * 60 * 1000),
      lastUpdated: new Date(now.getTime() - 3 * 24 * 60 * 60 * 1000),
      cvssScore: 6.8,
      impact: "medium",
      exploitability: "medium",
      fixComplexity: "low",
      estimatedFixTime: 1,
      tags: ["xss", "search", "frontend"]
    },
    {
      id: "vuln-5",
      type: "xss",
      title: "DOM-based XSS in Profile Page",
      description: "Client-side JavaScript processes user input without validation.",
      severity: "high",
      status: "fixed",
      target: "/profile",
      discoveredAt: new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000),
      lastUpdated: new Date(now.getTime() - 1 * 24 * 60 * 60 * 1000),
      cvssScore: 7.2,
      impact: "medium",
      exploitability: "medium",
      fixComplexity: "medium",
      estimatedFixTime: 3,
      assignedTo: "Frontend Team",
      tags: ["xss", "profile", "dom"]
    },
    {
      id: "vuln-6",
      type: "csrf",
      title: "CSRF in Password Change",
      description: "Password change endpoint lacks CSRF protection.",
      severity: "medium",
      status: "open",
      target: "/api/user/change-password",
      discoveredAt: new Date(now.getTime() - 4 * 24 * 60 * 60 * 1000),
      lastUpdated: new Date(now.getTime() - 4 * 24 * 60 * 60 * 1000),
      cvssScore: 5.4,
      impact: "medium",
      exploitability: "medium",
      fixComplexity: "low",
      estimatedFixTime: 2,
      tags: ["csrf", "authentication", "security"]
    },
    {
      id: "vuln-7",
      type: "info-disclosure",
      title: "Sensitive Data in Error Messages",
      description: "Database errors expose sensitive information to users.",
      severity: "medium",
      status: "in-progress",
      target: "/api/*",
      discoveredAt: new Date(now.getTime() - 6 * 24 * 60 * 60 * 1000),
      lastUpdated: new Date(now.getTime() - 1 * 24 * 60 * 60 * 1000),
      cvssScore: 4.3,
      impact: "low",
      exploitability: "low",
      fixComplexity: "medium",
      estimatedFixTime: 6,
      assignedTo: "Backend Team",
      tags: ["information-disclosure", "error-handling"]
    },
    {
      id: "vuln-8",
      type: "file-upload",
      title: "Unrestricted File Upload",
      description: "File upload functionality allows dangerous file types.",
      severity: "medium",
      status: "fixed",
      target: "/api/upload",
      discoveredAt: new Date(now.getTime() - 10 * 24 * 60 * 60 * 1000),
      lastUpdated: new Date(now.getTime() - 2 * 24 * 60 * 60 * 1000),
      cvssScore: 6.1,
      impact: "medium",
      exploitability: "medium",
      fixComplexity: "medium",
      estimatedFixTime: 4,
      assignedTo: "Backend Team",
      tags: ["file-upload", "validation"]
    },
    {
      id: "vuln-9",
      type: "auth-bypass",
      title: "Authentication Bypass in Admin Panel",
      description: "Admin panel can be accessed without proper authentication.",
      severity: "critical",
      status: "fixed",
      target: "/admin",
      discoveredAt: new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000),
      lastUpdated: new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000),
      cve: "CVE-2024-1236",
      cvssScore: 9.1,
      impact: "high",
      exploitability: "high",
      fixComplexity: "high",
      estimatedFixTime: 12,
      assignedTo: "Security Team",
      tags: ["authentication", "authorization", "admin"]
    },
    {
      id: "vuln-10",
      title: "Weak Session Management",
      type: "auth-bypass",
      description: "Session tokens are predictable and lack proper expiration.",
      severity: "medium",
      status: "open",
      target: "/api/auth/*",
      discoveredAt: new Date(now.getTime() - 8 * 24 * 60 * 60 * 1000),
      lastUpdated: new Date(now.getTime() - 8 * 24 * 60 * 60 * 1000),
      cvssScore: 5.8,
      impact: "medium",
      exploitability: "medium",
      fixComplexity: "high",
      estimatedFixTime: 16,
      tags: ["session", "authentication", "security"]
    },
    {
      id: "vuln-11",
      type: "info-disclosure",
      title: "Directory Listing Enabled",
      description: "Web server allows directory browsing in sensitive locations.",
      severity: "low",
      status: "open",
      target: "/uploads/",
      discoveredAt: new Date(now.getTime() - 12 * 24 * 60 * 60 * 1000),
      lastUpdated: new Date(now.getTime() - 12 * 24 * 60 * 60 * 1000),
      cvssScore: 3.1,
      impact: "low",
      exploitability: "low",
      fixComplexity: "low",
      estimatedFixTime: 1,
      tags: ["configuration", "information-disclosure"]
    },
    {
      id: "vuln-12",
      type: "info-disclosure",
      title: "Verbose Error Messages",
      description: "Application reveals stack traces and internal paths in error responses.",
      severity: "low",
      status: "fixed",
      target: "/api/*",
      discoveredAt: new Date(now.getTime() - 15 * 24 * 60 * 60 * 1000),
      lastUpdated: new Date(now.getTime() - 5 * 24 * 60 * 60 * 1000),
      cvssScore: 2.7,
      impact: "low",
      exploitability: "low",
      fixComplexity: "low",
      estimatedFixTime: 2,
      assignedTo: "Backend Team",
      tags: ["error-handling", "information-disclosure"]
    }
  ]

  return vulnerabilities.sort((a, b) => {
    // Sort by severity first, then by discovery date
    const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 }
    const severityDiff = severityOrder[b.severity] - severityOrder[a.severity]
    if (severityDiff !== 0) return severityDiff
    return b.discoveredAt.getTime() - a.discoveredAt.getTime()
  })
}

// Calculate vulnerability statistics
function calculateVulnerabilityStats(vulnerabilities: VulnerabilityItem[]): VulnerabilityStats {
  const stats = vulnerabilities.reduce(
    (acc, vuln) => {
      acc[vuln.severity]++
      acc.total++

      if (vuln.status === "fixed") acc.fixed++
      else if (vuln.status === "in-progress") acc.inProgress++
      else acc.open++

      return acc
    },
    { critical: 0, high: 0, medium: 0, low: 0, total: 0, fixed: 0, inProgress: 0, open: 0 }
  )

  return stats
}

// Calculate risk metrics
function calculateRiskMetrics(vulnerabilities: VulnerabilityItem[]): RiskMetrics {
  if (vulnerabilities.length === 0) {
    return {
      riskScore: 0,
      slaCompliance: 100,
      averageFixTime: 0,
      criticalSlaBreaches: 0,
      trendDirection: "stable",
      trendPercentage: 0
    }
  }

  // Calculate risk score (0-10) based on severity and CVSS scores
  const riskScore = vulnerabilities.reduce((acc, vuln) => {
    const severityWeight = { critical: 4, high: 3, medium: 2, low: 1 }
    const cvssWeight = vuln.cvssScore ? vuln.cvssScore / 10 : 0.5
    const statusWeight = vuln.status === "open" ? 1 : vuln.status === "in-progress" ? 0.5 : 0

    return acc + (severityWeight[vuln.severity] * cvssWeight * statusWeight)
  }, 0) / vulnerabilities.length

  // Calculate SLA compliance (assuming 7 days for critical, 14 for high, 30 for medium, 90 for low)
  const now = new Date()
  const slaBreaches = vulnerabilities.filter(vuln => {
    if (vuln.status === "fixed") return false

    const daysSinceDiscovery = (now.getTime() - vuln.discoveredAt.getTime()) / (1000 * 60 * 60 * 24)
    const slaThreshold = {
      critical: 7,
      high: 14,
      medium: 30,
      low: 90
    }

    return daysSinceDiscovery > slaThreshold[vuln.severity]
  })

  const slaCompliance = ((vulnerabilities.length - slaBreaches.length) / vulnerabilities.length) * 100

  // Calculate average fix time for fixed vulnerabilities
  const fixedVulns = vulnerabilities.filter(v => v.status === "fixed")
  const averageFixTime = fixedVulns.length > 0
    ? fixedVulns.reduce((acc, vuln) => {
        const fixTime = (vuln.lastUpdated.getTime() - vuln.discoveredAt.getTime()) / (1000 * 60 * 60 * 24)
        return acc + fixTime
      }, 0) / fixedVulns.length
    : 0

  // Count critical SLA breaches
  const criticalSlaBreaches = slaBreaches.filter(v => v.severity === "critical").length

  // Simple trend calculation (would be more sophisticated with historical data)
  const recentVulns = vulnerabilities.filter(v => {
    const daysSinceDiscovery = (now.getTime() - v.discoveredAt.getTime()) / (1000 * 60 * 60 * 24)
    return daysSinceDiscovery <= 7
  })

  const olderVulns = vulnerabilities.filter(v => {
    const daysSinceDiscovery = (now.getTime() - v.discoveredAt.getTime()) / (1000 * 60 * 60 * 24)
    return daysSinceDiscovery > 7 && daysSinceDiscovery <= 14
  })

  let trendDirection: "up" | "down" | "stable" = "stable"
  let trendPercentage = 0

  if (olderVulns.length > 0) {
    const change = ((recentVulns.length - olderVulns.length) / olderVulns.length) * 100
    trendPercentage = Math.abs(change)

    if (change > 5) trendDirection = "up"
    else if (change < -5) trendDirection = "down"
  }

  return {
    riskScore: Math.min(10, Math.max(0, riskScore)),
    slaCompliance: Math.max(0, slaCompliance),
    averageFixTime,
    criticalSlaBreaches,
    trendDirection,
    trendPercentage
  }
}

// Get critical vulnerabilities that need immediate attention
function getCriticalActions(vulnerabilities: VulnerabilityItem[]): VulnerabilityItem[] {
  return vulnerabilities
    .filter(vuln =>
      (vuln.severity === "critical" || vuln.severity === "high") &&
      vuln.status !== "fixed"
    )
    .slice(0, 3) // Top 3 most critical
}

// Main hook
export function useVulnerabilityData() {
  const [vulnerabilities, setVulnerabilities] = useState<VulnerabilityItem[]>([])
  const [stats, setStats] = useState<VulnerabilityStats | null>(null)
  const [riskMetrics, setRiskMetrics] = useState<RiskMetrics | null>(null)
  const [criticalActions, setCriticalActions] = useState<VulnerabilityItem[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  // Real API call with fallback to mock data
  useEffect(() => {
    const fetchVulnerabilities = async () => {
      try {
        setLoading(true)
        setError(null)

        // ðŸ†• Try real API first
        try {
          const { vulnerabilityApi } = await import('@/lib/api')
          const { transformVulnerabilitiesData } = await import('@/utils/data-transformers')

          // Fetch real vulnerabilities from backend
          const vulnResponse = await vulnerabilityApi.getVulnerabilities({ limit: 100 })

          if (vulnResponse.data && Array.isArray(vulnResponse.data) && vulnResponse.data.length > 0) {
            // Transform backend data to frontend format
            const realVulns = transformVulnerabilitiesData(vulnResponse.data)

            // Convert to VulnerabilityItem format for chart
            const chartVulns = realVulns.map(vuln => ({
              id: vuln.id.toString(),
              type: vuln.vulnerability_type,
              title: vuln.title,
              description: vuln.description || '',
              severity: vuln.risk as VulnerabilityItem['severity'],
              status: vuln.status === 'fixed' ? 'fixed' : vuln.status === 'open' ? 'open' : 'in-progress',
              target: vuln.endpoint,
              discoveredAt: new Date(vuln.created_at),
              lastUpdated: new Date(vuln.created_at),
              cve: vuln.cwe_id || '',
              cvssScore: vuln.cvss_score || 0,
              impact: vuln.risk === 'critical' ? 'high' : vuln.risk === 'high' ? 'high' : 'medium',
              exploitability: vuln.confidence > 0.8 ? 'high' : vuln.confidence > 0.5 ? 'medium' : 'low',
              fixComplexity: 'medium',
              estimatedFixTime: vuln.risk === 'critical' ? 4 : vuln.risk === 'high' ? 8 : 16,
              assignedTo: 'Security Team',
              tags: [vuln.vulnerability_type, vuln.risk]
            }))

            setVulnerabilities(chartVulns)
            setStats(calculateVulnerabilityStats(chartVulns))
            setRiskMetrics(calculateRiskMetrics(chartVulns))
            setCriticalActions(getCriticalActions(chartVulns))

            console.log('Vulnerability data loaded from backend:', {
              count: chartVulns.length,
              types: [...new Set(chartVulns.map(v => v.type))]
            })

            return // Success - exit early
          }
        } catch (apiError) {
          console.warn('Failed to fetch real vulnerability data, falling back to mock:', apiError)
        }

        // ðŸ”„ Fallback to mock data if real API fails or returns empty
        console.log('Using mock vulnerability data for demonstration')
        const mockVulns = generateMockVulnerabilities()
        setVulnerabilities(mockVulns)
        setStats(calculateVulnerabilityStats(mockVulns))
        setRiskMetrics(calculateRiskMetrics(mockVulns))
        setCriticalActions(getCriticalActions(mockVulns))

      } catch (err) {
        setError("Failed to fetch vulnerability data")
        console.error("Error fetching vulnerabilities:", err)

        // Final fallback to mock data
        const mockVulns = generateMockVulnerabilities()
        setVulnerabilities(mockVulns)
        setStats(calculateVulnerabilityStats(mockVulns))
        setRiskMetrics(calculateRiskMetrics(mockVulns))
        setCriticalActions(getCriticalActions(mockVulns))
      } finally {
        setLoading(false)
      }
    }

    fetchVulnerabilities()
  }, [])

  // Auto-refresh every 5 minutes (reduced frequency)
  useEffect(() => {
    const interval = setInterval(() => {
      const mockVulns = generateMockVulnerabilities()
      setVulnerabilities(mockVulns)
      setStats(calculateVulnerabilityStats(mockVulns))
      setRiskMetrics(calculateRiskMetrics(mockVulns))
      setCriticalActions(getCriticalActions(mockVulns))
    }, 300000) // 5 minutes

    return () => clearInterval(interval)
  }, [])

  const refreshData = async () => {
    setLoading(true)
    try {
      // ðŸ†• Try real API first
      try {
        const { vulnerabilityApi } = await import('@/lib/api')
        const { transformVulnerabilitiesData } = await import('@/utils/data-transformers')

        const vulnResponse = await vulnerabilityApi.getVulnerabilities({ limit: 100 })

        if (vulnResponse.data && Array.isArray(vulnResponse.data) && vulnResponse.data.length > 0) {
          const realVulns = transformVulnerabilitiesData(vulnResponse.data)

          const chartVulns = realVulns.map(vuln => ({
            id: vuln.id.toString(),
            type: vuln.vulnerability_type,
            title: vuln.title,
            description: vuln.description || '',
            severity: vuln.risk as VulnerabilityItem['severity'],
            status: vuln.status === 'fixed' ? 'fixed' : vuln.status === 'open' ? 'open' : 'in-progress',
            target: vuln.endpoint,
            discoveredAt: new Date(vuln.created_at),
            lastUpdated: new Date(vuln.created_at),
            cve: vuln.cwe_id || '',
            cvssScore: vuln.cvss_score || 0,
            impact: vuln.risk === 'critical' ? 'high' : vuln.risk === 'high' ? 'high' : 'medium',
            exploitability: vuln.confidence > 0.8 ? 'high' : vuln.confidence > 0.5 ? 'medium' : 'low',
            fixComplexity: 'medium',
            estimatedFixTime: vuln.risk === 'critical' ? 4 : vuln.risk === 'high' ? 8 : 16,
            assignedTo: 'Security Team',
            tags: [vuln.vulnerability_type, vuln.risk]
          }))

          setVulnerabilities(chartVulns)
          setStats(calculateVulnerabilityStats(chartVulns))
          setRiskMetrics(calculateRiskMetrics(chartVulns))
          setCriticalActions(getCriticalActions(chartVulns))
          setError(null)

          console.log('Vulnerability data refreshed from backend')
          return
        }
      } catch (apiError) {
        console.warn('Failed to refresh real vulnerability data, using mock:', apiError)
      }

      // ðŸ”„ Fallback to mock data
      await new Promise(resolve => setTimeout(resolve, 300))
      const mockVulns = generateMockVulnerabilities()
      setVulnerabilities(mockVulns)
      setStats(calculateVulnerabilityStats(mockVulns))
      setRiskMetrics(calculateRiskMetrics(mockVulns))
      setCriticalActions(getCriticalActions(mockVulns))
      setError(null)

    } catch (err) {
      setError("Failed to refresh vulnerability data")
    } finally {
      setLoading(false)
    }
  }

  const getVulnerabilitiesByType = (type: VulnerabilityItem["type"]) => {
    return vulnerabilities.filter(v => v.type === type)
  }

  const getVulnerabilitiesBySeverity = (severity: VulnerabilityItem["severity"]) => {
    return vulnerabilities.filter(v => v.severity === severity)
  }

  const getVulnerabilitiesByStatus = (status: VulnerabilityItem["status"]) => {
    return vulnerabilities.filter(v => v.status === status)
  }

  return {
    vulnerabilities,
    stats,
    riskMetrics,
    criticalActions,
    loading,
    error,
    refreshData,
    getVulnerabilitiesByType,
    getVulnerabilitiesBySeverity,
    getVulnerabilitiesByStatus
  }
}
